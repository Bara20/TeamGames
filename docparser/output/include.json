var objects = {"CreateDirectoryPath": {"returnType": "void", "objType": "functions", "kind": "stock", "arguments": [{"type": "const char[]", "name": "dirPath"}, {"type": "int", "name": "mode"}, {"type": "bool", "name": "containsFile"}]}, "DispatchKeyValueFormat": {"returnType": "bool", "objType": "functions", "kind": "stock", "arguments": [{"type": "int", "name": "entity"}, {"type": "const char[]", "name": "keyName"}, {"type": "const char[]", "name": "format"}, {"type": "any", "name": "..."}]}, "DispatchKeyValueNum": {"returnType": "bool", "objType": "functions", "kind": "stock", "arguments": [{"type": "int", "name": "entity"}, {"type": "const char[]", "name": "keyName"}, {"type": "int", "name": "value"}]}, "GetCmdArgFloat": {"returnType": "int", "objType": "functions", "kind": "stock", "arguments": [{"type": "int", "name": "argnum"}]}, "GetCmdArgInt": {"returnType": "int", "objType": "functions", "kind": "stock", "arguments": [{"type": "int", "name": "argnum"}]}, "GivePlayerWeaponAndAmmo": {"returnType": "int", "objType": "functions", "kind": "stock", "arguments": [{"type": "int", "name": "client"}, {"type": "char[]", "name": "weapon"}, {"type": "int", "name": "clip"}, {"type": "int", "name": "ammo"}]}, "SetPlayerWeaponAmmo": {"returnType": "void", "objType": "functions", "kind": "stock", "arguments": [{"type": "int", "name": "client"}, {"type": "int", "name": "weaponEnt"}, {"type": "int", "name": "clip"}, {"type": "int", "name": "ammo"}]}, "TG_AreEnemies": {"returnDoc": "True if given players are enemies", "kind": "stock", "docText": "Returns wheter players are enemies within given game type. If there is not game type passed, game type of current game is taken.", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "First player", "type": "int", "name": "client1"}, {"docText": "Second player", "type": "int", "name": "client2"}, {"defaultValue": "TG_None", "type": "TG_GameType", "name": "gameType"}]}, "TG_AreTeamsEnemies": {"returnDoc": "True if given team are enemies", "kind": "stock", "docText": "Returns wheter teams are enemies within given game type. If there is not game type passed, game type of current game is taken.", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "First team", "type": "TG_Team", "name": "team1"}, {"docText": "Second team", "type": "TG_Team", "name": "team2"}, {"defaultValue": "TG_None", "type": "TG_GameType", "name": "gameType"}]}, "TG_AskModuleName": {"kind": "forward", "docText": "Core asks module for name.", "objType": "functions", "arguments": [{"docText": "Module type", "type": "TG_ModuleType", "name": "type"}, {"docText": "Module ID", "type": "const char[]", "name": "id"}, {"docText": "Client index (target for translation)", "type": "int", "name": "client"}, {"docText": "Buffer for module name", "type": "char[]", "name": "name"}, {"docText": "Max size of the buffer", "type": "int", "name": "nameSize"}, {"docText": "Menu item status", "type": "TG_MenuItemStatus", "name": "status", "byReference": 1}], "returnType": "void"}, "TG_AttachPlayerHealthBar": {"kind": "native", "docText": "Attach HealthBar to player. Uses file prefix [HealthBar] in downloads config.", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}, {"docText": "Client max health level to calculate HealthBar percent level from.", "defaultValue": "100", "type": "int", "name": "maxHealth"}, {"docText": "Automatically destroy HealthBar when client leaves TG game.", "defaultValue": "true", "type": "bool", "name": "destroyOnLeaveGame"}], "returnType": "void"}, "TG_CheckModuleAccess": {"returnDoc": "True on success, false otherwise.", "kind": "stock", "docText": "Checks player's TG module access via SourceMod override system. <br/> 1. step: Check access for \"TG_MenuItem-ModuleID\" or \"TG_Game-ModuleID\" (depending on module type). <br/> 2. step: Check access for \"ModuleID\".", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}, {"docText": "Module type.", "type": "TG_ModuleType", "name": "type"}, {"docText": "Module ID.", "type": "const char[]", "name": "moduleID"}]}, "TG_ClearTeam": {"kind": "native", "docText": "Remove all players from the given TeamGames team.", "objType": "functions", "arguments": [{"docText": "TG team", "type": "TG_Team", "name": "team"}], "returnType": "void"}, "TG_DestroyMark": {"kind": "native", "docText": "Destroy mark.", "objType": "functions", "arguments": [{"docText": "Mark handle.", "type": "Handle", "name": "mark"}], "returnType": "void"}, "TG_DestroyPlayerHealthBar": {"kind": "native", "docText": "Destroy player's HealthBar.", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}], "returnType": "void"}, "TG_FakeSelect": {"kind": "native", "docText": "Fake player select in TeamGames menu", "objType": "functions", "arguments": [{"docText": "Client index", "type": "int", "name": "client"}, {"docText": "Game type used when fake selecting a game", "type": "TG_ModuleType", "name": "type"}, {"docText": "Module ID", "type": "char[]", "name": "id"}, {"defaultValue": "TG_None", "type": "TG_GameType", "name": "gameType"}], "returnType": "void"}, "TG_FenceCreate": {"returnDoc": "True on success, false on failure.", "kind": "native", "docText": "Create fence from two points (a, c) on diagonale.", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "Array with x,y,z coordinates of point a.", "type": "float[3]", "name": "a"}, {"docText": "Array with x,y,z coordinates of point c.", "type": "float[3]", "name": "c"}]}, "TG_FenceDestroy": {"kind": "native", "docText": "Destroy existing fence.", "objType": "functions", "arguments": [], "returnType": "void"}, "TG_FencePlayerCross": {"kind": "native", "docText": "Punish player for crossing the laser fence.", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}, {"defaultValue": "true", "type": "bool", "name": "callForward"}], "returnType": "void"}, "TG_GAME_SETTINGS_LENGTH": {"docText": "Max game settings length", "objType": "constants", "value": "64"}, "TG_GameProgress": {"docText": "TeamGames game status", "objType": "enums", "entries": [{"docText": "There is no game running or in preparation. TG_GetCurrentGameID and TG_GetGameName(\"CurrentGameId\") returns \"Core_NoGame\"", "name": "TG_NoGame"}, {"docText": "The game is in preparation", "name": "TG_InPreparation"}, {"docText": "The game is running", "name": "TG_InProgress"}]}, "TG_GameType": {"docText": "TeamGames game type", "objType": "enums", "entries": [{"name": "TG_None"}, {"docText": "TeamGame game type: RedTeam vs. BlueTeam", "name": "TG_TeamGame"}, {"docText": "RedOnly game type: only red players are allowed", "name": "TG_RedOnly"}]}, "TG_GetCurrentDataPack": {"returnDoc": "DataPack Handle on success, INVALID_HANDLE otherwise (no DataPack or no running game).", "kind": "native", "docText": "Retrieves current game DataPack.", "returnType": "Handle", "objType": "functions", "arguments": []}, "TG_GetCurrentGameID": {"returnDoc": "True on success, false on failure (buffer is smaller then TG_MODULE_ID_LENGTH).", "kind": "native", "docText": "Retrieves current game id.", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "Buffer for game id", "type": "char[]", "name": "id"}, {"docText": "Size of buffer.", "type": "int", "name": "size"}]}, "TG_GetCurrentGameSettings": {"returnDoc": "True on success, false otherwise (no settings or no running game).", "kind": "native", "docText": "Retrieves current game settings.", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "Buffer for current game settings.", "type": "char[]", "name": "gameSettings"}, {"docText": "Buffer size.", "type": "int", "name": "size"}]}, "TG_GetCurrentGameType": {"returnDoc": "Current game type or TG_None if there is not game.", "kind": "native", "docText": "Retrieves current game type.", "returnType": "TG_GameType", "objType": "functions", "arguments": []}, "TG_GetCurrentStarter": {"returnDoc": "Client index on success, 0 otherwise (no starter or no running game).", "kind": "native", "docText": "Retrieves current game starter (Player who started the game).", "returnType": "int", "objType": "functions", "arguments": []}, "TG_GetGameStatus": {"returnDoc": "Game status.", "kind": "native", "docText": "Retrieves game status.", "returnType": "TG_GameProgress", "objType": "functions", "arguments": []}, "TG_GetGameType": {"returnDoc": "Returns game type of the given game id.", "kind": "native", "docText": "Retrieves game type.", "returnType": "TG_GameType", "objType": "functions", "arguments": [{"docText": "Game ID.", "type": "const char[]", "name": "id"}]}, "TG_GetModuleName": {"returnDoc": "Returns game type of the given game id.", "kind": "native", "docText": "Retrieves module name.", "returnType": "int", "objType": "functions", "arguments": [{"docText": "Module type.", "type": "TG_ModuleType", "name": "type"}, {"docText": "Module ID.", "type": "const char[]", "name": "id"}, {"docText": "Client used as translation target. Use LANG_SERVER for default name.", "type": "int", "name": "client"}, {"docText": "Buffer to store the name.", "type": "char[]", "name": "name"}, {"docText": "Buffer max size.", "type": "int", "name": "size"}]}, "TG_GetModuleVisibility": {"returnDoc": "Module visibility.", "kind": "native", "docText": "Retrieves module visibility.", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "Module type", "type": "TG_ModuleType", "name": "type"}, {"docText": "Module ID", "type": "const char[]", "name": "id"}]}, "TG_GetOppositeTeam": {"returnDoc": "Oposite TG team.", "kind": "stock", "docText": "Returns oposite TG team. <br/> Red -> Blue <br/> Blue -> Red", "returnType": "TG_Team", "objType": "functions", "arguments": [{"docText": "TG team.", "type": "TG_Team", "name": "team"}]}, "TG_GetPlayerTeam": {"returnDoc": "TG team.", "kind": "native", "docText": "Get client TeamGames team.", "returnType": "TG_Team", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}]}, "TG_GetRandomClient": {"returnDoc": "Client index on success, 0 otherwise.", "kind": "stock", "docText": "Get random client from TG team.", "returnType": "int", "objType": "functions", "arguments": [{"docText": "TG team.", "type": "TG_Team", "name": "team"}]}, "TG_GetRegedModules": {"returnDoc": "Handle to adt array with module ids on success, INVALID_HANDLE otherwise.", "kind": "native", "docText": "Retrieves all registred modules of the given type.", "returnType": "Handle", "objType": "functions", "arguments": [{"docText": "Module type", "type": "TG_ModuleType", "name": "type"}]}, "TG_GetTeamCount": {"returnDoc": "Count (>= 0) of players in the given team.", "kind": "native", "docText": "Get count of players in the given TeamGames team.", "returnType": "int", "objType": "functions", "arguments": [{"docText": "TG team to count players in.", "type": "TG_Team", "name": "team"}]}, "TG_GetTeamFromString": {"returnDoc": "TG team.", "kind": "stock", "docText": "Converts string to TG team.", "returnType": "TG_Team", "objType": "functions", "arguments": [{"docText": "String to convert.", "type": "const char[]", "name": "team"}]}, "TG_GetTeamsLock": {"returnDoc": "True or false (true = teams are locked, false = teams are unlocked).", "kind": "native", "docText": "Get teams lock.", "returnType": "bool", "objType": "functions", "arguments": []}, "TG_InOppositeTeams": {"returnDoc": "True on (client 1 team != client 2 team), false otherwise.", "kind": "stock", "docText": "Are players in different teams? (Red vs. Blue or Blue vs. Red)", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "Client 1 index.", "type": "int", "name": "client1"}, {"docText": "Client 2 index.", "type": "int", "name": "client2"}]}, "TG_IsCurrentGameID": {"returnDoc": "True on success, false otherwise.", "kind": "native", "docText": "Check if current game id is also the given game id.", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "Game id.", "type": "const char[]", "name": "id"}]}, "TG_IsGameStatus": {"returnDoc": "True on success, false otherwise.", "kind": "native", "docText": "Checks if the given status is also the current status.", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "Game status to check.", "type": "TG_GameProgress", "name": "status"}]}, "TG_IsGameTypeAvailable": {"kind": "native", "docText": "Check if the given game type is available depending on TeamGames teams population.", "objType": "functions", "arguments": [{"docText": "Game type. $return     True on success, false on failure.", "type": "TG_GameType", "name": "type"}], "returnType": "bool"}, "TG_IsModuleReged": {"returnDoc": "True if the given module is registred, false otherwise.", "kind": "native", "docText": "Check if the given module is registred.", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "Module type", "type": "TG_ModuleType", "name": "type"}, {"docText": "Module ID", "type": "const char[]", "name": "id"}]}, "TG_IsPlayerRedOrBlue": {"returnDoc": "True on success, false otherwise.", "kind": "stock", "docText": "Is player in TG team (Red or Blue)?", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}]}, "TG_IsTeamRedOrBlue": {"returnDoc": "True on success, false otherwise.", "kind": "stock", "docText": "Is TG team Red or Blue?", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "TG team.", "type": "TG_Team", "name": "team"}]}, "TG_IsTeamValid": {"returnDoc": "True on success, false otherwise.", "kind": "stock", "docText": "Is TG team valid? (Red, Blue or None)", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "TG team.", "type": "TG_Team", "name": "team"}]}, "TG_LoadPlayerWeapons": {"returnDoc": "True on success, false on failure.", "kind": "native", "docText": "Loads saved player weapons, health and armor.", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}]}, "TG_LogGameMessage": {"kind": "native", "docText": "Logs a game message to the TeamGames logs.", "objType": "functions", "arguments": [{"docText": "Game ID.", "type": "const char[]", "name": "gameID"}, {"docText": "Messge prefix.", "defaultValue": "\"\"", "type": "const char[]", "name": "prefix"}, {"docText": "String format.", "defaultValue": "\"\"", "type": "const char[]", "name": "format"}, {"docText": "Format arguments.", "type": "any", "name": "..."}], "returnType": "void"}, "TG_LogMessage": {"kind": "native", "docText": "Logs a module message to the TeamGames logs.", "objType": "functions", "arguments": [{"docText": "Messge prefix.", "defaultValue": "\"\"", "type": "const char[]", "name": "prefix"}, {"docText": "String format.", "defaultValue": "\"\"", "type": "const char[]", "name": "format"}, {"docText": "Format arguments.", "type": "any", "name": "..."}], "returnType": "void"}, "TG_LogRoundMessage": {"kind": "native", "docText": "Logs a module round message to the TeamGames logs.", "objType": "functions", "arguments": [{"docText": "Messge prefix.", "defaultValue": "\"\"", "type": "const char[]", "name": "prefix"}, {"docText": "String format.", "defaultValue": "\"\"", "type": "const char[]", "name": "format"}, {"docText": "Format arguments.", "type": "any", "name": "..."}], "returnType": "void"}, "TG_MODULE_ID_LENGTH": {"docText": "Max module ID length", "objType": "constants", "value": "64"}, "TG_MODULE_NAME_LENGTH": {"docText": "Max module name length", "objType": "constants", "value": "64"}, "TG_MenuItemStatus": {"docText": "TeamGames menu item status", "objType": "enums", "entries": [{"docText": "Menu item is in menu and selecable", "name": "TG_Active"}, {"docText": "Menu item is in menu, but not selectable", "name": "TG_Inactive"}, {"docText": "Menu item is not in menu", "name": "TG_Disabled"}]}, "TG_ModuleType": {"docText": "TeamGames module type", "objType": "enums", "entries": [{"docText": "Game module", "name": "TG_Game"}, {"docText": "Menu item (appears in TeamGames main menu)", "name": "TG_MenuItem"}]}, "TG_OnDownloadFile": {"kind": "forward", "docText": "Called when core finds a prefixed file in TeamGames downloads config. <br/> Note: If it's called for your prefixed file, set arg. known as true! Otherwise, core will log error.", "objType": "functions", "arguments": [{"docText": "File path.", "type": "char[]", "name": "file"}, {"docText": "File prefix.", "type": "char[]", "name": "prefixName"}, {"docText": "Prefix arguments (Use DTC).", "type": "Handle", "name": "args"}, {"docText": "Is the prefix known or not.", "type": "bool", "name": "known", "byReference": 1}], "returnType": "void"}, "TG_OnDownloadsEnd": {"kind": "forward", "docText": "Called right after core ended parsing the TeamGames downloads config.", "objType": "functions", "arguments": [], "returnType": "void"}, "TG_OnDownloadsStart": {"kind": "forward", "docText": "Called right before core starts parsing the TeamGames downloads config.", "objType": "functions", "arguments": [], "returnType": "void"}, "TG_OnGameEnd": {"kind": "forward", "docText": "Called on TG_StopGame() (or one TG team is empty - depending of settings).", "objType": "functions", "arguments": [{"docText": "Game ID.", "type": "const char[]", "name": "id"}, {"docText": "Game type.", "type": "TG_GameType", "name": "gameType"}, {"docText": "Winner team.", "type": "TG_Team", "name": "team"}, {"docText": "Array of winners (all alive players in winner team by default).", "type": "int[]", "name": "winners"}, {"docText": "Number of winners.", "type": "int", "name": "winnersCount"}, {"docText": "Game datapack.", "type": "Handle", "name": "dataPack"}], "returnType": "void"}, "TG_OnGamePrepare": {"kind": "forward", "docText": "Called when game preparation started.", "objType": "functions", "arguments": [{"docText": "Game ID.", "type": "const char[]", "name": "id"}, {"docText": "Game type.", "type": "TG_GameType", "name": "gameType"}, {"docText": "Client index of game starter.", "type": "int", "name": "client"}, {"docText": "Game settings.", "type": "const char[]", "name": "gameSettings"}, {"docText": "Game datapack.", "type": "Handle", "name": "dataPack"}], "returnType": "void"}, "TG_OnGamePreparePre": {"returnDoc": "Plugin_Handled to block game preparation from starting (and so game).", "kind": "forward", "docText": "Called right before game preparation starts.", "returnType": "Action", "objType": "functions", "arguments": [{"docText": "Game ID.", "type": "const char[]", "name": "id"}, {"docText": "Game type.", "type": "TG_GameType", "name": "gameType"}, {"docText": "Client index of game starter.", "type": "int", "name": "client"}, {"docText": "Game settings.", "type": "const char[]", "name": "gameSettings"}, {"docText": "Game datapack.", "type": "Handle", "name": "dataPack"}]}, "TG_OnGameStart": {"kind": "forward", "docText": "Called when game started.", "objType": "functions", "arguments": [{"docText": "Game ID.", "type": "const char[]", "name": "id"}, {"docText": "Game type.", "type": "TG_GameType", "name": "gameType"}, {"docText": "Client index of game starter.", "type": "int", "name": "client"}, {"docText": "Game settings.", "type": "const char[]", "name": "gameSettings"}, {"docText": "Game datapack.", "type": "Handle", "name": "dataPack"}], "returnType": "void"}, "TG_OnGameStartError": {"kind": "forward", "docText": "Called when some error happened in TG_StartGame().", "objType": "functions", "arguments": [{"docText": "Game ID.", "type": "const char[]", "name": "id"}, {"docText": "Game type.", "type": "TG_GameType", "name": "gameType"}, {"docText": "Client index of game starter.", "type": "int", "name": "client"}, {"docText": "Game start error id.", "type": "int", "name": "errorID"}, {"docText": "Game start error description.", "type": "const char[]", "name": "errorDescription"}], "returnType": "void"}, "TG_OnGameStartMenu": {"returnDoc": "Plugin_Handled to block start menu from opening.", "kind": "forward", "docText": "Called before game start menu is opened.", "returnType": "Action", "objType": "functions", "arguments": [{"docText": "Game ID.", "type": "const char[]", "name": "id"}, {"docText": "Game type.", "type": "TG_GameType", "name": "gameType"}, {"docText": "Client index of game starter.", "type": "int", "name": "client"}, {"docText": "Game settings.", "type": "const char[]", "name": "gameSettings"}, {"docText": "Game datapack.", "type": "Handle", "name": "dataPack"}]}, "TG_OnLaserFenceCreate": {"returnDoc": "Plugin_Handled to block laser fence creation.", "kind": "forward", "docText": "Called when fence is about to be created.", "returnType": "Action", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}, {"docText": "Coordinates of point a.", "type": "float[3]", "name": "a"}, {"docText": "Coordinates of point c.", "type": "float[3]", "name": "c"}]}, "TG_OnLaserFenceCreated": {"kind": "forward", "docText": "Called right after the laser fence was created.", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}, {"docText": "Coordinates of point a.", "type": "float[3]", "name": "a"}, {"docText": "Coordinates of point c.", "type": "float[3]", "name": "c"}], "returnType": "void"}, "TG_OnLaserFenceCross": {"returnDoc": "Plugin_Handled to block punishment and TG_OnLaserFenceCrossed.", "kind": "forward", "docText": "Called when player is crossing the laser fence.", "returnType": "Action", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}, {"docText": "Punishment length.", "type": "float", "name": "punishTime"}]}, "TG_OnLaserFenceCrossed": {"kind": "forward", "docText": "Called right after player crossed the laser fence.", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}, {"docText": "Punishment length.", "type": "float", "name": "punishTime"}], "returnType": "void"}, "TG_OnLaserFenceDestroyed": {"kind": "forward", "docText": "Called right before the laser fence is destroyed.", "objType": "functions", "arguments": [{"docText": "Coordinates of point a.", "type": "float[3]", "name": "a"}, {"docText": "Coordinates of point c.", "type": "float[3]", "name": "c"}], "returnType": "void"}, "TG_OnMarkDestroyed": {"kind": "forward", "docText": "Called right after the mark was destroyed.", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}, {"docText": "Player team.", "type": "const TG_Team", "name": "team"}, {"docText": "Mark position.", "type": "float[3]", "name": "position"}, {"docText": "Mark life.", "type": "float", "name": "life", "byReference": 1}, {"docText": "Mark handle.", "type": "Handle", "name": "mark"}, {"docText": "Mark entity (env_sprite) or INVALID_ENT_REFERENCE if entity wasn't created.", "type": "int", "name": "markent"}], "returnType": "void"}, "TG_OnMarkSpawn": {"returnDoc": "Plugin_Handled to block mark creation.", "kind": "forward", "docText": "Called when mark is about to spawn.", "returnType": "Action", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}, {"docText": "Player team.", "type": "TG_Team", "name": "team"}, {"docText": "Mark position.", "type": "float[3]", "name": "position"}, {"docText": "Mark life.", "type": "float", "name": "life"}]}, "TG_OnMarkSpawned": {"kind": "forward", "docText": "Called right after the mark was spawned.", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}, {"docText": "Player team.", "type": "TG_Team", "name": "team"}, {"docText": "Mark position.", "type": "float[3]", "name": "position"}, {"docText": "Mark life.", "type": "float", "name": "life", "byReference": 1}, {"docText": "Mark handle.", "type": "const Handle", "name": "mark"}, {"docText": "Mark entity (env_sprite) or INVALID_ENT_REFERENCE if entity wasn't created.", "type": "int", "name": "markent", "byReference": 1}], "returnType": "void"}, "TG_OnMenuDisplay": {"returnDoc": "Plugin_Handled to block menu from displaying.", "kind": "forward", "docText": "Called right before the TeamGames menu is displayed.", "returnType": "Action", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}]}, "TG_OnMenuDisplayed": {"kind": "forward", "docText": "Called after the TeamGames menu was displayed.", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}], "returnType": "void"}, "TG_OnMenuSelect": {"returnDoc": "Plugin_Handled to block item from selecting.", "kind": "forward", "docText": "Called right before player selects an item in TeamGames menu. <br/> Might be: core item, module item or game!", "returnType": "Action", "objType": "functions", "arguments": [{"docText": "Module type.", "type": "TG_ModuleType", "name": "type"}, {"docText": "Module ID.", "type": "const char[]", "name": "id"}, {"docText": "Game type used when selecting a game", "type": "TG_GameType", "name": "gameType"}, {"docText": "Client index.", "type": "int", "name": "client"}]}, "TG_OnMenuSelected": {"kind": "forward", "docText": "Called after player selected an item in TeamGames menu. <br/> Might be: core item, module item or game!", "objType": "functions", "arguments": [{"docText": "Module type.", "type": "TG_ModuleType", "name": "type"}, {"docText": "Module ID.", "type": "const char[]", "name": "id"}, {"docText": "Game type used when selecting a game", "type": "TG_GameType", "name": "gameType"}, {"docText": "Client index.", "type": "int", "name": "client"}], "returnType": "void"}, "TG_OnPlayerDamage": {"returnType": "Action", "objType": "functions", "kind": "forward", "arguments": [{"type": "bool", "name": "inTeamGame"}, {"type": "int", "name": "victim"}, {"type": "int", "name": "attacker", "byReference": 1}, {"type": "int", "name": "inflictor", "byReference": 1}, {"type": "float", "name": "damage", "byReference": 1}, {"type": "int", "name": "damageType", "byReference": 1}]}, "TG_OnPlayerDeath": {"kind": "forward", "docText": "Called when player (from RedTeam or BlueTeam) dies.", "objType": "functions", "arguments": [{"docText": "Client index of attacker.", "type": "int", "name": "attacker"}, {"docText": "Attacker's TG team.", "type": "TG_Team", "name": "attackerTeam"}, {"docText": "Client index of victim.", "type": "int", "name": "victim"}, {"docText": "Victim's TG team.", "type": "TG_Team", "name": "victimTeam"}, {"docText": "Was it headshot?", "type": "bool", "name": "headshot"}, {"docText": "Killer's weapon.", "type": "const char[]", "name": "weapon"}, {"docText": "Game status.", "type": "TG_GameProgress", "name": "gameStatus"}, {"docText": "Game ID.", "type": "const char[]", "name": "gameID"}, {"docText": "Game type.", "type": "TG_GameType", "name": "gameType"}], "returnType": "void"}, "TG_OnPlayerLeaveGame": {"kind": "forward", "docText": "Called when player leave TG game.", "objType": "functions", "arguments": [{"docText": "Game ID.", "type": "const char[]", "name": "id"}, {"docText": "Game type.", "type": "TG_GameType", "name": "gameType"}, {"docText": "Client index.", "type": "int", "name": "client"}, {"docText": "Player's TG team.", "type": "TG_Team", "name": "team"}, {"docText": "Why player left the game.", "type": "TG_PlayerTrigger", "name": "trigger"}], "returnType": "void"}, "TG_OnPlayerRebel": {"returnDoc": "Plugin_Handled to prevent player becoming a rebel.", "kind": "forward", "docText": "Called when player is about to become a rebel.", "returnType": "Action", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}, {"docText": "Player team.", "type": "TG_Team", "name": "team"}]}, "TG_OnPlayerRebelPost": {"kind": "forward", "docText": "Called right after player became a rebel.", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}, {"docText": "Player team.", "type": "TG_Team", "name": "team"}], "returnType": "void"}, "TG_OnPlayerTeam": {"returnDoc": "Plugin_Handled to prevent player changing team.", "kind": "forward", "docText": "Called when player is about to be moved to TeamGames team.", "returnType": "Action", "objType": "functions", "arguments": [{"docText": "Client index of switched player.", "type": "int", "name": "client"}, {"docText": "Client index of activator (see TG_SetPlayerTeam).", "type": "int", "name": "activator"}, {"docText": "Team before.", "type": "TG_Team", "name": "teamBefore"}, {"docText": "Team after.", "type": "TG_Team", "name": "teamAfter"}]}, "TG_OnPlayerTeamPost": {"kind": "forward", "docText": "Called right after player was moved to TeamGames team.", "objType": "functions", "arguments": [{"docText": "Client index of switched player.", "type": "int", "name": "client"}, {"docText": "Client index of activator (see TG_SetPlayerTeam).", "type": "int", "name": "activator"}, {"docText": "Team before.", "type": "TG_Team", "name": "teamBefore"}, {"docText": "Team after.", "type": "TG_Team", "name": "teamAfter"}], "returnType": "void"}, "TG_OnTeamEmpty": {"kind": "forward", "docText": "Called when one TG team was emptied.", "objType": "functions", "arguments": [{"docText": "Game ID (\"Core_NoGame\" if there is no game running).", "type": "const char[]", "name": "id"}, {"docText": "Game type.", "type": "TG_GameType", "name": "gameType"}, {"docText": "Client index.", "type": "int", "name": "client"}, {"docText": "Player's TG team.", "type": "TG_Team", "name": "team"}, {"docText": "How was the team emptied.", "type": "TG_PlayerTrigger", "name": "trigger"}], "returnType": "void"}, "TG_OnTraceAttack": {"returnType": "Action", "objType": "functions", "kind": "forward", "arguments": [{"type": "bool", "name": "inTeamGame"}, {"type": "int", "name": "victim"}, {"type": "int", "name": "attacker", "byReference": 1}, {"type": "int", "name": "inflictor", "byReference": 1}, {"type": "float", "name": "damage", "byReference": 1}, {"type": "int", "name": "damageType", "byReference": 1}, {"type": "int", "name": "ammoType", "byReference": 1}, {"type": "int", "name": "hitBox"}, {"type": "int", "name": "hitGroup"}]}, "TG_PlayerSelectMenuHandler": {"docText": "Prototype for TG_ShowPlayerSelectMenu callback.", "objType": "typedefs", "type": "function void(int activator, int client, bool IsRandom, any data)", "tags": [{"docText": "Custom data cell passed to callback.", "type": "any", "name": "data"}, {"docText": "Client index of chosen player.", "type": "int", "name": "client"}, {"docText": "True if activator chosed random player, false otherwise.", "type": "bool", "name": "IsRandom"}, {"docText": "Activator's client index (who used select menu).", "type": "int", "name": "activator"}]}, "TG_PlayerTrigger": {"docText": "TeamGames player triggers/reasons of leaving game or emptying team", "objType": "enums", "entries": [{"docText": "Player died", "name": "TG_Death"}, {"docText": "Player became a rebel", "name": "TG_Rebel"}, {"docText": "Player changed TeamGames team", "name": "TG_ChangeTGTeam"}, {"docText": "TeamGames game ended", "name": "TG_GameEnd"}, {"docText": "Player disconnected", "name": "TG_Disconnect"}, {"docText": "Currently not used", "name": "TG_Other"}]}, "TG_RegGame": {"returnDoc": "0 on success, otherwise on failure.", "kind": "native", "docText": "Register Game to TeamGames.", "returnType": "int", "objType": "functions", "arguments": [{"docText": "Game ID (!!! MUST BE UNIQUE !!!).", "type": "const char[]", "name": "id"}, {"docText": "Game type.", "defaultValue": "TG_TeamGame", "type": "TG_GameType", "name": "type"}, {"defaultValue": "true", "type": "bool", "name": "enemyhealthbar"}]}, "TG_RegMenuItem": {"returnDoc": "0 on success, otherwise on failure.", "kind": "native", "docText": "Register (add) item to TeamGames main menu.", "returnType": "int", "objType": "functions", "arguments": [{"docText": "Item ID (!!! MUST BE UNIQUE !!!).", "type": "const char[]", "name": "id"}]}, "TG_RemoveGame": {"returnDoc": "0 on success, otherwise on failure.", "kind": "native", "docText": "Unregister (remove) game from TeamGames.", "returnType": "int", "objType": "functions", "arguments": [{"docText": "Game ID.", "type": "const char[]", "name": "id"}]}, "TG_RemoveMenuItem": {"returnDoc": "0 on success, otherwise on failure.", "kind": "native", "docText": "Unregister (remove) item from TeamGames main menu.", "returnType": "int", "objType": "functions", "arguments": [{"docText": "Item ID.", "type": "const char[]", "name": "id"}]}, "TG_SetModuleVisibility": {"returnDoc": "True on success, false otherwise.", "kind": "native", "docText": "Set module visibility.", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "Module type", "type": "TG_ModuleType", "name": "type"}, {"docText": "Module ID", "type": "const char[]", "name": "id"}, {"docText": "Module visibility", "type": "bool", "name": "visibility"}]}, "TG_SetPlayerTeam": {"returnDoc": "True on success, false on failure.", "kind": "native", "docText": "Set client TeamGames team", "returnType": "bool", "objType": "functions", "arguments": [{"docText": "Activator client index (use non valid client index for set client team without the activator). <br/> valid client index = Checks teams lock and move delay. Uses phrases PlayerMove-NoneTeam|RedTeam|BlueTeam. <br/> 0 = Checks teams lock and move delay. No phrase in chat. <br/> -1 = No lock or delay checks. Uses phrases PlayerMove-RedTeam|BlueTeam-Game (only if there is running game).", "type": "int", "name": "activator"}, {"docText": "Client index to move.", "type": "int", "name": "client"}, {"docText": "TG team to move to.", "type": "TG_Team", "name": "team"}]}, "TG_SetTeamsLock": {"kind": "native", "docText": "Set teams lock.", "objType": "functions", "arguments": [{"docText": "True or false (true = lock teams, false = unlock teams).", "type": "bool", "name": "lock"}], "returnType": "void"}, "TG_ShowPlayerSelectMenu": {"returnDoc": "False if there are no players to be in the menu, True otherwise.", "kind": "native", "docText": "Opens menu for choosing player from TG team. <br/> If there is only one player in selected TG teams, the menu is skiped and callback is called imediately.", "returnType": "int", "objType": "functions", "arguments": [{"docText": "Client index to open menu for.", "type": "int", "name": "client"}, {"docText": "Callback function to call after player selection.", "type": "TG_PlayerSelectMenuHandler", "name": "callBack"}, {"docText": "Allow Red team in menu.", "defaultValue": "true", "type": "bool", "name": "redTeam"}, {"docText": "Allow Blue team in menu.", "defaultValue": "true", "type": "bool", "name": "blueTeam"}, {"docText": "Allow random player option in menu.", "defaultValue": "true", "type": "bool", "name": "random"}, {"docText": "Pass data cell to callback.", "defaultValue": "0", "type": "any", "name": "data"}, {"docText": "Format string for menu heading.", "defaultValue": "\"\"", "type": "const char[]", "name": "format"}, {"docText": "Format string arguments.", "type": "any", "name": "..."}]}, "TG_SpawnMark": {"returnDoc": "Mark handle on success, INVALID_HANDLE otherwise.", "kind": "native", "docText": "Spawn mark.", "returnType": "Handle", "objType": "functions", "arguments": [{"docText": "Client index of who spawned the mark. Use 0 for no client.", "type": "int", "name": "client"}, {"docText": "TG team who owns the mark.", "type": "TG_Team", "name": "team"}, {"docText": "Mark's position.", "type": "float[3]", "name": "position"}, {"docText": "Mark's life.", "defaultValue": "0.0", "type": "float", "name": "life"}, {"docText": "Call forward TG_OnMarkSpawn?", "defaultValue": "true", "type": "bool", "name": "callForward"}, {"docText": "Use marks counter (works only for valid clients).", "defaultValue": "false", "type": "bool", "name": "counter"}, {"docText": "Block DMG if mark is created by shooting and >Add 1 bullet to player's current weapon clip<.", "defaultValue": "false", "type": "bool", "name": "blockDMG"}]}, "TG_StartGame": {"kind": "native", "docText": "Start game (preparation for game and then game) with game id = @param id. And lock teams.", "objType": "functions", "arguments": [{"docText": "Client index who start game.", "type": "int", "name": "client"}, {"docText": "Game ID.", "type": "const char[]", "name": "id"}, {"docText": "Game type.", "defaultValue": "TG_TeamGame", "type": "TG_GameType", "name": "gameType"}, {"docText": "Game settings.", "defaultValue": "\"\"", "type": "const char[]", "name": "gameSettings"}, {"docText": "Game datapack.", "defaultValue": "INVALID_HANDLE", "type": "Handle", "name": "dataPack"}, {"docText": "Remove weapons that prisoners dropped.", "defaultValue": "false", "type": "bool", "name": "removeDroppedWeapons"}, {"docText": "Automatically end game when one team was emptied (is that even word?).", "defaultValue": "true", "type": "bool", "name": "endOnTeamEmpty"}], "returnType": "void"}, "TG_StopGame": {"kind": "native", "docText": "Stops current game.", "objType": "functions", "arguments": [{"docText": "Winner team.", "type": "TG_Team", "name": "team"}, {"docText": "Adt array of winners. If INVALID_HANDLE, living players from winner team are used.", "defaultValue": "INVALID_HANDLE", "type": "Handle", "name": "winners", "byReference": 1}, {"defaultValue": "true", "type": "bool", "name": "clearTeams"}, {"defaultValue": "true", "type": "bool", "name": "returnWeapons"}], "returnType": "void"}, "TG_Team": {"docText": "TeamGames teams", "objType": "enums", "entries": [{"docText": "CTs, dead Ts, etc...", "name": "TG_ErrorTeam"}, {"docText": "Ts who are not in TeamGames team", "name": "TG_NoneTeam"}, {"docText": "Ts who are in TeamGames Red team", "name": "TG_RedTeam"}, {"docText": "Ts who are in TeamGames Blue team", "name": "TG_BlueTeam"}]}, "TG_UpdatePlayerHealthBar": {"kind": "native", "docText": "Update HealthBar acording to player's health level.", "objType": "functions", "arguments": [{"docText": "Client index.", "type": "int", "name": "client"}], "returnType": "void"}};
